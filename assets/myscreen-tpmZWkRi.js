import{j as e,c as o,r as t,H as d,F as h}from"./Footer-BCDbRi8S.js";import{w as x}from"./working-hard-NgNEVRNp.js";import{B as j}from"./chunk-QMGIS6GS-DFy_XklQ.js";const m="/assets/ibm1969-DPtM4P6B.jpg";function p(){return e.jsxs("div",{children:[e.jsxs("p",{children:["终端是什么？其实从UNIX用户的视角来看，终端和普通的文件没有什么区别。在UNIX系统里，一个程序可以用",e.jsx("code",{children:"open"}),"系统调用既可以打开一个文件，也可以打开一个终端设备。",e.jsx("code",{children:"open"}),"系统调用返回一个整数类型的文件描述符（其实就是一个数组下标），紧接着你就可以使用",e.jsx("code",{children:"read/write"}),"系统调用对这个文件描述符进行读写操作。许多时候，对于一个程序来说，一个文件描述符究竟属于一个磁盘文件还是属于一个终端设备并不重要，只要可以对这个文件描述符进行读写操作就可以。但是UNIX系统就需要区分文件描述符对应的设备是什么了。如果是读写硬盘，UNIX系统中的硬盘驱动程序会驱动硬盘的磁头读取磁道上的数据；如果是读写终端，UNIX系统中的终端驱动程序则需要等待键盘的输入，或者是把ascii码打印在屏幕上。"]}),e.jsx("p",{children:"所以终端这个名词其实可以对应两种东西：终端设备和终端驱动程序。在很早以前，终端设备，就是指键盘和屏幕；终端驱动则对中断驱动器编程读取键盘输入，并把字符对应的像素点画到显示器中。下面是一张古早（1969年，来源于维基百科）人们在终端上工作的相片（也许现在有一些性格变态的书呆子也会这么工作，林子大了什么鸟都有！）"}),e.jsx("div",{className:"ibm1969-pic",children:e.jsx("img",{src:m,alt:"ibm terminal in 1969"})}),e.jsx("p",{children:"现在终端设备已经变成了键盘加弹窗了，终端驱动程序也不再向整个显示器上打印字符，而是在弹窗中打印字符。你也许想说，听起来只是从显示器变成了弹窗，事实也确实如此。为了支持弹窗显示，现代UNIX系统加入了伪终端设备。"}),e.jsx("h3",{children:"🚧 施工中... 🚧"})]})}function b(){return e.jsx("div",{children:e.jsx("h3",{children:"🚧 施工中... 🚧"})})}function u(){return e.jsxs("div",{children:[e.jsx("h3",{children:"🚧 施工中... 🚧"}),e.jsx("img",{src:x,alt:"work in progress gif",className:"work-in-progress-img"})]})}const l=[{id:"introTerm",label:"终端"},{id:"introWin",label:"窗口管理"},{id:"introCode",label:"myscreen"}];function N({sectionRefs:c}){const[a,r]=t.useState("");return t.useEffect(()=>{const s=new IntersectionObserver(n=>{n.forEach(i=>{i.isIntersecting&&r(i.target.id)})},{rootMargin:"-40% 0px -60% 0px",threshold:0});return Object.values(c.current).forEach(n=>{n&&s.observe(n)}),()=>s.disconnect()},[]),console.log("hello"+a),e.jsx("aside",{children:e.jsx("ul",{className:"myscreen-toc",children:l.map(s=>e.jsx("li",{children:e.jsx("a",{className:a===s.id?"active":"",href:`#${s.id}`,onClick:n=>{var i;n.preventDefault(),(i=c.current[s.id])==null||i.scrollIntoView({behavior:"smooth"})},children:s.label})},s.id))})})}function f({sectionRefs:c}){const a=new Map([["introTerm",{content:p()}],["introWin",{content:b()}],["introCode",{content:u()}]]);return e.jsxs("div",{className:"myscreen-body",children:[e.jsx("h1",{children:"MyScreen: 编写一个简单的screen程序"}),e.jsxs("div",{className:"notice",children:["👉 ",e.jsx("code",{children:"myscreen"}),"的代码在",e.jsx("a",{href:"https://github.com/brandb97/myscreen.git",children:"这个仓库"})]}),e.jsxs("p",{className:"content",children:[e.jsx("span",{className:"QA",children:"Q"}),"：如果你正在命令行窗口中工作，比如你打开了一个bash窗口。这时你准备做机器学习的课程实验，而实验结果需要几个小时才能跑完。你希望可以一边运行实验，一边在bash中处理手头的其他工作，你会怎么做？",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"A"}),"：我会用bg命令让实验脚本在后台运行，或者我干脆新开一个bash窗口运行实验脚本。",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"Q"}),"：可是实验必须在远程服务器上完成，如果你的机器学习老师疯了，给你们安排的实验需要运行12个小时，但是你没法12个小时都在远程服务器上保持登陆状态，你该怎么办？",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"A"}),"：我敢肯定南京大学的老师不会这么做的......",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"Q"}),"：You never know！",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"A"}),"：好吧，假设现实真的如此，我碰巧知道当退出bash时，bash会向所有后台程序发送SIGHUP信号。让实验脚本忽略SIGHUP很简单，使用nohup......",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"Q"}),"：你的老师不准你安装nohup",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"A"}),"：你是不是想让我说screen",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"Q"}),"：exactly！screen可以新建一个窗口，并在这个窗口中运行任何程序。按下CTRL-A d就可以让这个窗口在后台运行，即使退出登陆也没有关系。接下来，让我给你讲讲怎么样写一个具有和screen类似功能的myscreen程序吧。",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"A"}),"：TL;DR"]}),l.map(r=>{var s;return e.jsxs("section",{id:r.id,ref:n=>c.current[r.id]=n,className:"myscreen-section",children:[e.jsxs("h2",{children:[e.jsx("a",{href:`#${r.id}`,className:"anchor-link",children:"§"})," ",r.label]}),e.jsx("div",{className:"content",children:(s=a.get(r.id))==null?void 0:s.content})]},r.id)})]})}function v(){const c=t.useRef({});return e.jsxs(e.Fragment,{children:[e.jsx(d,{}),e.jsxs("div",{className:"myscreen-layout",children:[e.jsx(N,{sectionRefs:c}),e.jsx(f,{sectionRefs:c})]}),e.jsx(h,{})]})}o.createRoot(document.getElementById("root")).render(e.jsx(t.StrictMode,{children:e.jsx(j,{children:e.jsx(v,{})})}));

import{j as e,c as d,r as l,H as h,F as x}from"./Footer-BCDbRi8S.js";import{C as a,B as j}from"./CodeBox-DHD9yWMe.js";import{w as m}from"./working-hard-NgNEVRNp.js";const p="/assets/ibm1969-DPtM4P6B.jpg";function u(){return e.jsxs("div",{children:[e.jsxs("p",{className:"indent",children:["终端是什么？其实从UNIX用户的视角来看，终端和普通的文件没有什么区别。在UNIX系统里，一个程序可以用",e.jsx("code",{children:"open"}),"系统调用既可以打开一个文件，也可以打开一个终端设备。",e.jsx("code",{children:"open"}),"系统调用返回一个整数类型的文件描述符（其实就是一个数组下标），紧接着你就可以使用",e.jsx("code",{children:"read/write"}),"系统调用对这个文件描述符进行读写操作。许多时候，对于一个程序来说，一个文件描述符究竟属于一个磁盘文件还是属于一个终端设备并不重要，只要可以对这个文件描述符进行读写操作就可以。但是UNIX系统就需要区分文件描述符对应的设备是什么了。如果是读写硬盘，UNIX系统中的硬盘驱动程序会驱动硬盘的磁头读取磁道上的数据；如果是读写终端，UNIX系统中的终端驱动程序则需要等待键盘的输入，或者是把ascii码打印在屏幕上。"]}),e.jsx("p",{className:"indent",children:"所以终端这个名词其实可以对应两种东西：终端设备和终端驱动程序。在很早以前，终端设备，就是指键盘和屏幕；终端驱动则对中断驱动器编程读取键盘输入，并把字符对应的像素点画到显示器中。下面是一张古早（1969年，来源于维基百科）人们在终端上工作的相片（也许现在有一些性格变态的书呆子也会这么工作，林子大了什么鸟都有！）"}),e.jsx("div",{className:"ibm1969-pic",children:e.jsx("img",{src:p,alt:"ibm terminal in 1969"})}),e.jsxs("div",{className:"tips",children:["🤔 为什么终端被称为tty？",e.jsx("br",{}),"💡 tty的全称是TeleTYpewriter，如果你想了解更多，请看",e.jsx("a",{href:"https://zh.wikipedia.org/zh-cn/電傳打字機",children:"电传打印机"})]})]})}function N(){return e.jsxs("div",{children:[e.jsx("p",{className:"indent",children:"还记得我说过“大部分程序不关心文件描述符是什么设备”吗？但的确存在一些程序就是针对终端编写的，比如vim。想想vim要如何实现页面滚动的功能呢？首先，vim需要告诉终端驱动程序关闭行缓冲功能。在默认情况下，终端驱动程序会在用户按下ENTER时才把输入发送给应用程序，但对于vim，如果我们每次要到按“下箭头+ENTER”才能向下滚动显然很不方便。其次，在读取到用户输入的下箭头之后，vim需要结合光标的位置和终端显示器的宽度判断是否需要滚动页面。在UNIX系统中，用来获取和设置终端的系统调用如下所示："}),e.jsx(a,{code:`/* 获取终端属性，e.g.是否行缓冲 */
int tcgetattr(int fildes, struct termios *termios_p);

/* 设置终端属性 */
int tcsetattr(int fildes, int optional_actions, const struct termios *termios_p);

struct winsize {
    unsigned short ws_row;
    unsigned short ws_col;
    unsigned short ws_xpixel;
    unsigned short ws_ypixel;
} ws;

if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == -1)
    fprintf(stderr, "读取终端窗口大小错误\\n");`,language:"c"}),e.jsxs("p",{className:"indent",children:["抛开vim不谈，你是否想过当按你下CTRL-C时为什么可以让程序终止呢？当用户输入了CTRL-C，终端驱动并不会将CTRL-C放到输入缓冲区供程序读取，取而代之的事情是，终端驱动会向程序发送SIGINT，从而导致程序终止。那么，如何让终端驱动不要这么做呢？你可以使用系统调用",e.jsx("code",{children:"tcsetattr"}),"，或者更简单的，你可以使用",e.jsx("code",{children:"stty"}),"命令："]}),e.jsx(a,{code:`stty -isig   # 不允许特殊字符发送信号
stty isig    # 恢复特殊字符发送信号
stty intr ^L # 设置中断信号对于的字符是CTRL-L`,language:"bash"}),e.jsxs("p",{className:"indent",children:["说了这么多，大家应该明白：除了读写操作，终端文件描述符和普通文件描述符的区别很大。比如我们可以用上面提到的方法从终端文件描述符中获取许多普通文件描述符中没有的信息。但是普通文件符能做的",e.jsx("code",{children:"lseek"}),"（将磁盘读写头移到文件的某个指定位置），则无法在终端文件描述符中设置。"]})]})}function b(){return e.jsx("div",{children:e.jsx("p",{className:"indent",children:"古早时期，窗口=显示器。但现在，我们会在显示器中打开一大堆窗口，每个窗口中运行一个应用程序。一个应用程序的结构可以用下面这幅图片描述"})})}function v(){return e.jsxs("div",{children:[e.jsx("h3",{children:"🚧 施工中... 🚧"}),e.jsx("img",{src:m,alt:"work in progress gif",className:"work-in-progress-img"})]})}const o=[{id:"introTerm",label:"终端",level:2},{id:"controlTerm",label:"终端驱动",level:3},{id:"introWin",label:"窗口管理",level:2},{id:"introCode",label:"myscreen",level:2}];function f({sectionRefs:i}){const[t,n]=l.useState("");return l.useEffect(()=>{const s=new IntersectionObserver(r=>{r.forEach(c=>{c.isIntersecting&&n(c.target.id)})},{rootMargin:"-40% 0px -60% 0px",threshold:0});return Object.values(i.current).forEach(r=>{r&&s.observe(r)}),()=>s.disconnect()},[]),console.log("hello"+t),e.jsx("aside",{children:e.jsx("ul",{className:"myscreen-toc",children:o.map(s=>e.jsx("li",{children:e.jsx("a",{className:`${t===s.id?"active":"normal"}-${s.level}`,href:`#${s.id}`,onClick:r=>{var c;r.preventDefault(),(c=i.current[s.id])==null||c.scrollIntoView({behavior:"smooth"})},children:s.label})},s.id))})})}function g({sectionRefs:i}){const t=new Map([["introTerm",{content:u()}],["controlTerm",{content:N()}],["introWin",{content:b()}],["introCode",{content:v()}]]);return e.jsxs("div",{className:"myscreen-body",children:[e.jsx("h1",{children:"MyScreen: 编写一个简单的screen程序"}),e.jsxs("div",{className:"notice",children:["👉 ",e.jsx("code",{children:"myscreen"}),"的代码在",e.jsx("a",{href:"https://github.com/brandb97/myscreen.git",children:"这个仓库"})]}),e.jsxs("p",{className:"content",children:[e.jsx("span",{className:"QA",children:"Q"}),"：如果你正在命令行窗口中工作，比如你打开了一个bash窗口。这时你准备做机器学习的课程实验，而实验结果需要几个小时才能跑完。你希望可以一边运行实验，一边在bash中处理手头的其他工作，你会怎么做？",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"A"}),"：我会用bg命令让实验脚本在后台运行，或者我干脆新开一个bash窗口运行实验脚本。",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"Q"}),"：可是实验必须在远程服务器上完成，如果你的机器学习老师疯了，给你们安排的实验需要运行12个小时，但是你没法12个小时都在远程服务器上保持登陆状态，你该怎么办？",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"A"}),"：我敢肯定南京大学的老师不会这么做的......",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"Q"}),"：You never know！",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"A"}),"：好吧，假设现实真的如此，我碰巧知道当退出bash时，bash会向所有后台程序发送SIGHUP信号。让实验脚本忽略SIGHUP很简单，使用nohup......",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"Q"}),"：你的老师不准你安装nohup",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"A"}),"：你是不是想让我说screen",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"Q"}),"：exactly！screen可以新建一个窗口，并在这个窗口中运行任何程序。按下CTRL-A d就可以让这个窗口在后台运行，即使退出登陆也没有关系。接下来，让我给你讲讲怎么样写一个具有和screen类似功能的myscreen程序吧。",e.jsx("br",{}),e.jsx("span",{className:"QA",children:"A"}),"：TL;DR"]}),o.map(n=>{var s;return e.jsxs("section",{id:n.id,ref:r=>i.current[n.id]=r,className:"myscreen-section",children:[n.level===2?e.jsxs("h2",{children:[e.jsx("a",{href:`#${n.id}`,className:"anchor-link",children:"§"})," ",n.label]}):e.jsxs("h3",{children:[e.jsx("a",{href:`#${n.id}`,className:"anchor-link",children:"§"})," ",n.label]}),e.jsx("div",{className:"content",children:(s=t.get(n.id))==null?void 0:s.content})]},n.id)})]})}function y(){const i=l.useRef({});return e.jsxs(e.Fragment,{children:[e.jsx(h,{}),e.jsxs("div",{className:"myscreen-layout",children:[e.jsx(f,{sectionRefs:i}),e.jsx(g,{sectionRefs:i})]}),e.jsx(x,{})]})}d.createRoot(document.getElementById("root")).render(e.jsx(l.StrictMode,{children:e.jsx(j,{children:e.jsx(y,{})})}));
